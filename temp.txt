// 🔧 FIXED: Socket setup with proper room assignment
export default function setupSocket(io) {
  const playerSockets = new Map();
  const adminSockets = new Set();

  io.on('connection', (socket) => {
    console.log('User connected:', socket.id);

    // 🔧 FIX: Use a more reliable room tracking system
    let currentParticipant = null;
    let currentGameRoom = null;

    socket.on('join', async (message) => {
      console.log('🎭 Fashion Show - Received join:', message);

      if (!message.playerId || !message.catId) {
        console.warn('⚠️ Missing playerId or catId. Disconnecting.');
        return socket.disconnect();
      }

      // Validate cat ownership BEFORE creating participant
      try {
        const catValidation = await DB.query(
          'SELECT cat_id FROM player_cats WHERE cat_id = $1 AND player_id = $2',
          [message.catId, message.playerId]
        );

        if (catValidation.rows.length === 0) {
          console.warn(`❌ Player ${message.playerId} does not own cat ${message.catId}. Disconnecting.`);
          socket.emit('error', { message: 'Invalid cat selection' });
          return socket.disconnect();
        }
      } catch (err) {
        console.error('❌ Database error during cat validation:', err);
        socket.emit('error', { message: 'Database error' });
        return socket.disconnect();
      }

      // Check for duplicate participants
      const isDuplicate = waitingRoom.participants.some(p => 
        p.playerId === message.playerId || 
        (p.playerId === message.playerId && p.catId === message.catId)
      );

      if (isDuplicate) {
        console.warn(`❌ Player ${message.playerId} already in waiting room. Disconnecting duplicate.`);
        socket.emit('error', { message: 'You are already in the waiting room' });
        return socket.disconnect();
      }

      // Create participant
      socket.participant = await createParticipant(message.playerId, message.catId, socket);
      currentParticipant = socket.participant;
      
      // Validate participant was created successfully
      if (!socket.participant || !socket.participant.catName || socket.participant.catName.startsWith('Cat_')) {
        console.warn(`❌ Failed to create valid participant for player ${message.playerId}, cat ${message.catId}`);
        socket.emit('error', { message: 'Failed to load cat data' });
        return socket.disconnect();
      }

      console.log(`✅ Valid participant created for ${socket.participant.playerId}: ${socket.participant.catName}`);

      if (waitingRoom.participants.length < PARTICIPANTS_IN_ROOM && !waitingRoom.isVoting) {
        waitingRoom.participants.push(socket.participant);

        console.log(`👥 Waiting room: ${waitingRoom.participants.length}/${PARTICIPANTS_IN_ROOM}`);
        
        // Debug: Log all participants to verify no duplicates
        console.log('👥 Current waiting room participants:');
        waitingRoom.participants.forEach((p, idx) => {
          console.log(`  ${idx + 1}. Player ${p.playerId} with cat ${p.catId} (${p.catName})`);
        });

        broadcastWaitingRoomUpdate();

        // Launch game room when full
        if (waitingRoom.participants.length === PARTICIPANTS_IN_ROOM) {
          console.log('🚀 Launching game room');
          
          // Final validation before game start
          const uniqueParticipants = waitingRoom.participants.filter((p, index, arr) => 
            arr.findIndex(other => other.playerId === p.playerId && other.catId === p.catId) === index
          );

          if (uniqueParticipants.length !== PARTICIPANTS_IN_ROOM) {
            console.error(`❌ Duplicate participants detected! Expected ${PARTICIPANTS_IN_ROOM}, got ${uniqueParticipants.length} unique`);
            // Reset waiting room and disconnect all
            waitingRoom.participants.forEach(p => {
              if (p.socket?.connected) {
                p.socket.emit('error', { message: 'Room error - please try again' });
                p.socket.disconnect();
              }
            });
            waitingRoom = { participants: [], isVoting: false };
            return;
          }

          const gameRoom = new GameRoom([...uniqueParticipants]);

          // 🔧 FIX: Properly assign game room to all participant sockets
          uniqueParticipants.forEach(p => {
            if (!p.isDummy && p.socket) {
              p.socket.currentGameRoom = gameRoom; // Use a clear property name
              console.log(`🔗 Assigned game room to ${p.username}'s socket`);
            }
          });

          // Reset waiting room
          waitingRoom = { participants: [], isVoting: false };
        }
      } else {
        console.warn('❌ Waiting room full or voting. Disconnecting.');
        socket.emit('error', { message: 'Room is full or voting in progress' });
        socket.disconnect();
      }
    });

    // 🔧 FIXED: Vote handling with proper room validation
    socket.on('vote', (message) => {
      console.log('🗳️ Received vote:', message);
      
      // Validate we have a participant and game room
      if (!currentParticipant) {
        console.warn('⚠️ Vote received but no participant on socket');
        return;
      }

      if (!socket.currentGameRoom) {
        console.warn('⚠️ Vote received but no game room assigned to socket');
        return;
      }

      if (!(socket.currentGameRoom instanceof GameRoom)) {
        console.warn('⚠️ Vote received but currentGameRoom is not a GameRoom instance');
        return;
      }

      if (socket.currentGameRoom.isFinalized) {
        console.warn('⚠️ Vote received but game room is already finalized');
        return;
      }

      console.log(`🗳️ Valid vote from ${currentParticipant.username} (${currentParticipant.playerId}) for cat ${message.votedCatId}`);
      socket.currentGameRoom.handleVote(currentParticipant, message.votedCatId);
    });

    socket.on('disconnect', () => {
      console.log('User disconnected:', socket.id);

      // Handle fashion show disconnect
      if (currentParticipant) {
        // Check if they're in waiting room
        const waitingRoomIdx = waitingRoom.participants.findIndex(p => 
          p.playerId === currentParticipant.playerId && p.catId === currentParticipant.catId
        );
        
        if (waitingRoomIdx > -1) {
          waitingRoom.participants.splice(waitingRoomIdx, 1);
          broadcastWaitingRoomUpdate();
          console.log(`👤 ${currentParticipant.playerId} left waiting room`);
        } else if (socket.currentGameRoom instanceof GameRoom) {
          socket.currentGameRoom.handleParticipantDisconnect(currentParticipant);
          console.log(`👤 ${currentParticipant.playerId} disconnected during game`);
        }
      }

      // Cleanup admin and player sockets
      adminSockets.delete(socket.id);
      for (const [userId, socketId] of playerSockets.entries()) {
        if (socketId === socket.id) {
          playerSockets.delete(userId);
          break;
        }
      }
    });
  });
}