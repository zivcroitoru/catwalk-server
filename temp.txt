// 🔧 FIXED: calculateResults - CALCULATION ONLY, NO DATABASE UPDATES
async calculateResults() {
  console.log('🧮 CALCULATING VOTE RESULTS (NO DB UPDATES YET)');
  console.log('='.repeat(50));

  // 🔧 ENHANCED: Log participant data integrity
  console.log('🔍 PARTICIPANT DATA INTEGRITY CHECK:');
  this.participants.forEach((p, idx) => {
    const catIdType = typeof p.catId;
    const catIdParsed = parseInt(p.catId);
    const isValidCatId = !isNaN(catIdParsed) && catIdParsed > 0;
    
    console.log(`  ${idx + 1}. ${p.username} (playerId: ${p.playerId})`);
    console.log(`     catId: ${p.catId} (type: ${catIdType}, parsed: ${catIdParsed}, valid: ${isValidCatId})`);
    console.log(`     isDummy: ${p.isDummy || false}`);
    
    if (!isValidCatId) {
      console.error(`     ❌ INVALID CATID DETECTED for ${p.username}!`);
    }
  });

  // 🔧 DEBUG: Log all participants and their votes before counting
  console.log('📊 VOTING STATE BEFORE COUNTING:');
  this.participants.forEach((p, idx) => {
    const hasVote = p.votedCatId !== null && p.votedCatId !== undefined;
    const voteType = typeof p.votedCatId;
    const voteParsed = hasVote ? parseInt(p.votedCatId) : 'N/A';
    
    console.log(`  ${idx + 1}. ${p.username} voted for: ${hasVote ? p.votedCatId : 'NO VOTE'}`);
    console.log(`     Vote type: ${voteType}, parsed: ${voteParsed}`);
  });

  // Count votes with explicit type handling and validation
  const votes = {};
  console.log('📊 DETAILED VOTE COUNTING:');

  this.participants.forEach(voter => {
    if (voter.votedCatId !== null && voter.votedCatId !== undefined && !isNaN(voter.votedCatId)) {
      const votedCatId = parseInt(voter.votedCatId);
      const voteKey = votedCatId.toString();
      
      // 🔧 ENHANCED: Validate the vote target exists
      const targetParticipant = this.participants.find(p => parseInt(p.catId) === votedCatId);
      
      if (!targetParticipant) {
        console.error(`  ❌ PHANTOM VOTE: ${voter.username} voted for non-existent cat ${votedCatId}`);
        return; // Skip this vote
      }
      
      votes[voteKey] = (votes[voteKey] || 0) + 1;
      
      console.log(`  ✅ ${voter.username} → ${targetParticipant.catName} (catId: ${votedCatId}, key: '${voteKey}', count: ${votes[voteKey]})`);
    } else {
      console.log(`  ⚠️ ${voter.username} has invalid vote: ${voter.votedCatId} (type: ${typeof voter.votedCatId})`);
    }
  });

  console.log('📈 FINAL VOTE TALLIES:');
  Object.entries(votes).forEach(([catIdStr, voteCount]) => {
    const catId = parseInt(catIdStr);
    const participant = this.participants.find(p => parseInt(p.catId) === catId);
    
    // 🔧 VALIDATION: Ensure vote count is integer
    if (!Number.isInteger(voteCount)) {
      console.error(`  ❌ NON-INTEGER VOTE COUNT: catId ${catIdStr} has ${voteCount} votes (type: ${typeof voteCount})`);
    }
    
    console.log(`  catId ${catIdStr}: ${voteCount} votes → ${participant?.catName || 'Unknown'}`);
  });

  // Calculate rewards with enhanced validation
  console.log('💰 DETAILED REWARD CALCULATION:');
  let totalCoinsDistributed = 0;

  this.participants.forEach(p => {
    const catId = parseInt(p.catId);
    const catIdKey = catId.toString();
    
    // 🔧 VALIDATION: Check catId parsing
    if (isNaN(catId)) {
      console.error(`  ❌ INVALID CATID: ${p.username} has unparseable catId: ${p.catId}`);
      p.votesReceived = 0;
      p.coinsEarned = 0;
      return;
    }
    
    p.votesReceived = votes[catIdKey] || 0;
    p.coinsEarned = p.votesReceived * 25;
    
    // 🔧 CRITICAL VALIDATION: Verify calculation
    const expectedCoins = p.votesReceived * 25;
    if (p.coinsEarned !== expectedCoins) {
      console.error(`  ❌ CALCULATION ERROR: ${p.username} - ${p.votesReceived} votes should be ${expectedCoins} coins, got ${p.coinsEarned}`);
    }
    
    if (!Number.isInteger(p.votesReceived)) {
      console.error(`  ❌ NON-INTEGER VOTES: ${p.username} has ${p.votesReceived} votes (type: ${typeof p.votesReceived})`);
    }
    
    if (!Number.isInteger(p.coinsEarned) || p.coinsEarned % 25 !== 0) {
      console.error(`  ❌ INVALID COIN AMOUNT: ${p.username} - ${p.coinsEarned} coins is not valid multiple of 25`);
    }
    
    totalCoinsDistributed += p.coinsEarned;
    
    console.log(`  💎 ${p.catName} (${p.username}): ${p.votesReceived} votes × 25 = ${p.coinsEarned} coins`);
    console.log(`     Key lookup: catId ${catId} → key '${catIdKey}' → votes[key] = ${votes[catIdKey] || 0}`);
  });

  console.log(`🏆 CALCULATION SUMMARY:`);
  console.log(`   Total votes cast: ${Object.values(votes).reduce((a, b) => a + b, 0)}`);
  console.log(`   Total coins to distribute: ${totalCoinsDistributed}`);
  console.log(`   Expected range: 0-500 coins (5 players × 0-4 votes × 25 coins)`);
  
  if (totalCoinsDistributed % 25 !== 0) {
    console.error(`   ❌ CRITICAL: Total coins ${totalCoinsDistributed} is not multiple of 25!`);
  }

  // Sort by votes for ranking display
  const sortedParticipants = [...this.participants].sort((a, b) => b.votesReceived - a.votesReceived);
  console.log(`🥇 Final rankings:`);
  sortedParticipants.forEach((p, index) => {
    const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : '🥉';
    console.log(`   ${medal} ${index + 1}. ${p.catName} - ${p.votesReceived} votes = ${p.coinsEarned} coins`);
  });

  // 🔧 CRITICAL CHANGE: NO DATABASE UPDATES HERE
  console.log('💡 CALCULATION COMPLETE - DATABASE UPDATES DEFERRED TO RESULTS DISPLAY');
  console.log('='.repeat(50));
}

// 🔧 NEW: Separate function to handle database updates during results display
async updateDatabaseWithRewards() {
  console.log('💳 APPLYING COIN REWARDS TO DATABASE (RESULTS DISPLAY PHASE)');
  console.log('─'.repeat(60));

  const dbUpdateResults = [];
  let successfulUpdates = 0;
  let failedUpdates = 0;
  let skippedUpdates = 0;

  // Update each participant's coins individually with error handling
  for (const participant of this.participants) {
    const updateResult = await this.updatePlayerCoins(participant, participant.coinsEarned);
    dbUpdateResults.push({
      playerId: participant.playerId,
      username: participant.username,
      coinsEarned: participant.coinsEarned,
      updateResult
    });

    if (updateResult.success) {
      if (updateResult.skipped) {
        skippedUpdates++;
      } else {
        successfulUpdates++;
      }
    } else {
      failedUpdates++;
      
      // 🔧 ENHANCED: Log validation failures in detail
      if (updateResult.error.includes('invalid_coin_amount')) {
        console.error(`🚨 COIN VALIDATION FAILURE: ${participant.username} attempted to receive ${updateResult.invalidAmount} coins`);
        console.error(`   Votes received: ${participant.votesReceived}`);
        console.error(`   Calculation: ${participant.votesReceived} × 25 = ${participant.coinsEarned}`);
        console.error(`   This indicates a vote counting or calculation bug!`);
      }
    }
  }

  // Log comprehensive update summary
  console.log('💳 DATABASE UPDATE SUMMARY:');
  console.log(`   ✅ Successful updates: ${successfulUpdates}`);
  console.log(`   ⏭️ Skipped updates: ${skippedUpdates}`);
  console.log(`   ❌ Failed updates: ${failedUpdates}`);

  // Enhanced detailed logging
  dbUpdateResults.forEach(result => {
    const { playerId, username, coinsEarned, updateResult } = result;
    
    if (updateResult.success && !updateResult.skipped) {
      console.log(`   💰 ${username} (${playerId}): +${coinsEarned} coins (${updateResult.previousTotal} → ${updateResult.newTotal})`);
    } else if (updateResult.skipped) {
      console.log(`   ⏭️ ${username} (${playerId}): skipped (${updateResult.reason})`);
    } else {
      console.log(`   ❌ ${username} (${playerId}): FAILED - ${updateResult.error}`);
      if (updateResult.invalidAmount !== undefined) {
        console.log(`      Invalid amount: ${updateResult.invalidAmount}`);
      }
    }
  });

  if (failedUpdates > 0) {
    console.warn(`⚠️ WARNING: ${failedUpdates} database updates failed!`);
  }

  console.log('✅ DATABASE UPDATES COMPLETE - COINS AWARDED AT RESULTS DISPLAY');
  console.log('─'.repeat(60));
  
  return {
    successfulUpdates,
    failedUpdates,
    skippedUpdates,
    dbUpdateResults
  };
}

// 🔧 MODIFIED: finalizeVoting - calculation only, no DB updates
finalizeVoting() {
  if (this.isFinalized) return;
  this.isFinalized = true;

  console.log('🏁 FINALIZING VOTING - No more changes allowed');
  
  // Record finalization time for analytics
  const votingDuration = ((Date.now() - this.votingStartTime) / 1000).toFixed(1);
  console.log(`⏱️ Voting lasted ${votingDuration} seconds`);

  // Clear timer if still running
  if (this.votingTimer) {
    clearTimeout(this.votingTimer);
    this.votingTimer = null;
    console.log('⏹️ Voting timer cleared');
  }

  // 🔧 CHANGED: Only calculate results, no database updates yet
  this.calculateResults();

  // Show announcement before results
  console.log('📺 Sending "calculating votes" announcement to participants');
  this.participants.forEach(participant => {
    if (participant.socket?.connected) {
      participant.socket.emit('calculating_announcement', {
        type: 'calculating_announcement',
        message: 'CALCULATING VOTES, PLEASE WAIT . . .'
      });
    }
  });

  // 🔧 CRITICAL CHANGE: Database updates happen here, right before sending results
  setTimeout(async () => {
    console.log('💰 RESULTS CALCULATED - NOW APPLYING DATABASE UPDATES');
    
    // 🔧 NEW: Update database with rewards ONLY when about to show results
    await this.updateDatabaseWithRewards();
    
    console.log('📤 Sending final results to all participants (coins already awarded)');
    this.participants.forEach(participant => {
      if (participant.socket?.connected) {
        participant.socket.emit('results', {
          type: 'results',
          participants: this.getParticipantsForClient()
        });
        console.log(`  ✅ Results sent to ${participant.username}`);
      } else {
        console.log(`  ⚠️ Could not send results to ${participant.username} - socket disconnected`);
      }
    });

    console.log('🎉 GAME ROOM COMPLETE - Results displayed, coins awarded in database');
  }, 3000);
}