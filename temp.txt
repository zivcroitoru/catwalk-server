// ğŸ”§ FIXED: calculateResults - CALCULATION ONLY, NO DATABASE UPDATES
async calculateResults() {
  console.log('ğŸ§® CALCULATING VOTE RESULTS (NO DB UPDATES YET)');
  console.log('='.repeat(50));

  // ğŸ”§ ENHANCED: Log participant data integrity
  console.log('ğŸ” PARTICIPANT DATA INTEGRITY CHECK:');
  this.participants.forEach((p, idx) => {
    const catIdType = typeof p.catId;
    const catIdParsed = parseInt(p.catId);
    const isValidCatId = !isNaN(catIdParsed) && catIdParsed > 0;
    
    console.log(`  ${idx + 1}. ${p.username} (playerId: ${p.playerId})`);
    console.log(`     catId: ${p.catId} (type: ${catIdType}, parsed: ${catIdParsed}, valid: ${isValidCatId})`);
    console.log(`     isDummy: ${p.isDummy || false}`);
    
    if (!isValidCatId) {
      console.error(`     âŒ INVALID CATID DETECTED for ${p.username}!`);
    }
  });

  // ğŸ”§ DEBUG: Log all participants and their votes before counting
  console.log('ğŸ“Š VOTING STATE BEFORE COUNTING:');
  this.participants.forEach((p, idx) => {
    const hasVote = p.votedCatId !== null && p.votedCatId !== undefined;
    const voteType = typeof p.votedCatId;
    const voteParsed = hasVote ? parseInt(p.votedCatId) : 'N/A';
    
    console.log(`  ${idx + 1}. ${p.username} voted for: ${hasVote ? p.votedCatId : 'NO VOTE'}`);
    console.log(`     Vote type: ${voteType}, parsed: ${voteParsed}`);
  });

  // Count votes with explicit type handling and validation
  const votes = {};
  console.log('ğŸ“Š DETAILED VOTE COUNTING:');

  this.participants.forEach(voter => {
    if (voter.votedCatId !== null && voter.votedCatId !== undefined && !isNaN(voter.votedCatId)) {
      const votedCatId = parseInt(voter.votedCatId);
      const voteKey = votedCatId.toString();
      
      // ğŸ”§ ENHANCED: Validate the vote target exists
      const targetParticipant = this.participants.find(p => parseInt(p.catId) === votedCatId);
      
      if (!targetParticipant) {
        console.error(`  âŒ PHANTOM VOTE: ${voter.username} voted for non-existent cat ${votedCatId}`);
        return; // Skip this vote
      }
      
      votes[voteKey] = (votes[voteKey] || 0) + 1;
      
      console.log(`  âœ… ${voter.username} â†’ ${targetParticipant.catName} (catId: ${votedCatId}, key: '${voteKey}', count: ${votes[voteKey]})`);
    } else {
      console.log(`  âš ï¸ ${voter.username} has invalid vote: ${voter.votedCatId} (type: ${typeof voter.votedCatId})`);
    }
  });

  console.log('ğŸ“ˆ FINAL VOTE TALLIES:');
  Object.entries(votes).forEach(([catIdStr, voteCount]) => {
    const catId = parseInt(catIdStr);
    const participant = this.participants.find(p => parseInt(p.catId) === catId);
    
    // ğŸ”§ VALIDATION: Ensure vote count is integer
    if (!Number.isInteger(voteCount)) {
      console.error(`  âŒ NON-INTEGER VOTE COUNT: catId ${catIdStr} has ${voteCount} votes (type: ${typeof voteCount})`);
    }
    
    console.log(`  catId ${catIdStr}: ${voteCount} votes â†’ ${participant?.catName || 'Unknown'}`);
  });

  // Calculate rewards with enhanced validation
  console.log('ğŸ’° DETAILED REWARD CALCULATION:');
  let totalCoinsDistributed = 0;

  this.participants.forEach(p => {
    const catId = parseInt(p.catId);
    const catIdKey = catId.toString();
    
    // ğŸ”§ VALIDATION: Check catId parsing
    if (isNaN(catId)) {
      console.error(`  âŒ INVALID CATID: ${p.username} has unparseable catId: ${p.catId}`);
      p.votesReceived = 0;
      p.coinsEarned = 0;
      return;
    }
    
    p.votesReceived = votes[catIdKey] || 0;
    p.coinsEarned = p.votesReceived * 25;
    
    // ğŸ”§ CRITICAL VALIDATION: Verify calculation
    const expectedCoins = p.votesReceived * 25;
    if (p.coinsEarned !== expectedCoins) {
      console.error(`  âŒ CALCULATION ERROR: ${p.username} - ${p.votesReceived} votes should be ${expectedCoins} coins, got ${p.coinsEarned}`);
    }
    
    if (!Number.isInteger(p.votesReceived)) {
      console.error(`  âŒ NON-INTEGER VOTES: ${p.username} has ${p.votesReceived} votes (type: ${typeof p.votesReceived})`);
    }
    
    if (!Number.isInteger(p.coinsEarned) || p.coinsEarned % 25 !== 0) {
      console.error(`  âŒ INVALID COIN AMOUNT: ${p.username} - ${p.coinsEarned} coins is not valid multiple of 25`);
    }
    
    totalCoinsDistributed += p.coinsEarned;
    
    console.log(`  ğŸ’ ${p.catName} (${p.username}): ${p.votesReceived} votes Ã— 25 = ${p.coinsEarned} coins`);
    console.log(`     Key lookup: catId ${catId} â†’ key '${catIdKey}' â†’ votes[key] = ${votes[catIdKey] || 0}`);
  });

  console.log(`ğŸ† CALCULATION SUMMARY:`);
  console.log(`   Total votes cast: ${Object.values(votes).reduce((a, b) => a + b, 0)}`);
  console.log(`   Total coins to distribute: ${totalCoinsDistributed}`);
  console.log(`   Expected range: 0-500 coins (5 players Ã— 0-4 votes Ã— 25 coins)`);
  
  if (totalCoinsDistributed % 25 !== 0) {
    console.error(`   âŒ CRITICAL: Total coins ${totalCoinsDistributed} is not multiple of 25!`);
  }

  // Sort by votes for ranking display
  const sortedParticipants = [...this.participants].sort((a, b) => b.votesReceived - a.votesReceived);
  console.log(`ğŸ¥‡ Final rankings:`);
  sortedParticipants.forEach((p, index) => {
    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : 'ğŸ¥‰';
    console.log(`   ${medal} ${index + 1}. ${p.catName} - ${p.votesReceived} votes = ${p.coinsEarned} coins`);
  });

  // ğŸ”§ CRITICAL CHANGE: NO DATABASE UPDATES HERE
  console.log('ğŸ’¡ CALCULATION COMPLETE - DATABASE UPDATES DEFERRED TO RESULTS DISPLAY');
  console.log('='.repeat(50));
}

// ğŸ”§ NEW: Separate function to handle database updates during results display
async updateDatabaseWithRewards() {
  console.log('ğŸ’³ APPLYING COIN REWARDS TO DATABASE (RESULTS DISPLAY PHASE)');
  console.log('â”€'.repeat(60));

  const dbUpdateResults = [];
  let successfulUpdates = 0;
  let failedUpdates = 0;
  let skippedUpdates = 0;

  // Update each participant's coins individually with error handling
  for (const participant of this.participants) {
    const updateResult = await this.updatePlayerCoins(participant, participant.coinsEarned);
    dbUpdateResults.push({
      playerId: participant.playerId,
      username: participant.username,
      coinsEarned: participant.coinsEarned,
      updateResult
    });

    if (updateResult.success) {
      if (updateResult.skipped) {
        skippedUpdates++;
      } else {
        successfulUpdates++;
      }
    } else {
      failedUpdates++;
      
      // ğŸ”§ ENHANCED: Log validation failures in detail
      if (updateResult.error.includes('invalid_coin_amount')) {
        console.error(`ğŸš¨ COIN VALIDATION FAILURE: ${participant.username} attempted to receive ${updateResult.invalidAmount} coins`);
        console.error(`   Votes received: ${participant.votesReceived}`);
        console.error(`   Calculation: ${participant.votesReceived} Ã— 25 = ${participant.coinsEarned}`);
        console.error(`   This indicates a vote counting or calculation bug!`);
      }
    }
  }

  // Log comprehensive update summary
  console.log('ğŸ’³ DATABASE UPDATE SUMMARY:');
  console.log(`   âœ… Successful updates: ${successfulUpdates}`);
  console.log(`   â­ï¸ Skipped updates: ${skippedUpdates}`);
  console.log(`   âŒ Failed updates: ${failedUpdates}`);

  // Enhanced detailed logging
  dbUpdateResults.forEach(result => {
    const { playerId, username, coinsEarned, updateResult } = result;
    
    if (updateResult.success && !updateResult.skipped) {
      console.log(`   ğŸ’° ${username} (${playerId}): +${coinsEarned} coins (${updateResult.previousTotal} â†’ ${updateResult.newTotal})`);
    } else if (updateResult.skipped) {
      console.log(`   â­ï¸ ${username} (${playerId}): skipped (${updateResult.reason})`);
    } else {
      console.log(`   âŒ ${username} (${playerId}): FAILED - ${updateResult.error}`);
      if (updateResult.invalidAmount !== undefined) {
        console.log(`      Invalid amount: ${updateResult.invalidAmount}`);
      }
    }
  });

  if (failedUpdates > 0) {
    console.warn(`âš ï¸ WARNING: ${failedUpdates} database updates failed!`);
  }

  console.log('âœ… DATABASE UPDATES COMPLETE - COINS AWARDED AT RESULTS DISPLAY');
  console.log('â”€'.repeat(60));
  
  return {
    successfulUpdates,
    failedUpdates,
    skippedUpdates,
    dbUpdateResults
  };
}

// ğŸ”§ MODIFIED: finalizeVoting - calculation only, no DB updates
finalizeVoting() {
  if (this.isFinalized) return;
  this.isFinalized = true;

  console.log('ğŸ FINALIZING VOTING - No more changes allowed');
  
  // Record finalization time for analytics
  const votingDuration = ((Date.now() - this.votingStartTime) / 1000).toFixed(1);
  console.log(`â±ï¸ Voting lasted ${votingDuration} seconds`);

  // Clear timer if still running
  if (this.votingTimer) {
    clearTimeout(this.votingTimer);
    this.votingTimer = null;
    console.log('â¹ï¸ Voting timer cleared');
  }

  // ğŸ”§ CHANGED: Only calculate results, no database updates yet
  this.calculateResults();

  // Show announcement before results
  console.log('ğŸ“º Sending "calculating votes" announcement to participants');
  this.participants.forEach(participant => {
    if (participant.socket?.connected) {
      participant.socket.emit('calculating_announcement', {
        type: 'calculating_announcement',
        message: 'CALCULATING VOTES, PLEASE WAIT . . .'
      });
    }
  });

  // ğŸ”§ CRITICAL CHANGE: Database updates happen here, right before sending results
  setTimeout(async () => {
    console.log('ğŸ’° RESULTS CALCULATED - NOW APPLYING DATABASE UPDATES');
    
    // ğŸ”§ NEW: Update database with rewards ONLY when about to show results
    await this.updateDatabaseWithRewards();
    
    console.log('ğŸ“¤ Sending final results to all participants (coins already awarded)');
    this.participants.forEach(participant => {
      if (participant.socket?.connected) {
        participant.socket.emit('results', {
          type: 'results',
          participants: this.getParticipantsForClient()
        });
        console.log(`  âœ… Results sent to ${participant.username}`);
      } else {
        console.log(`  âš ï¸ Could not send results to ${participant.username} - socket disconnected`);
      }
    });

    console.log('ğŸ‰ GAME ROOM COMPLETE - Results displayed, coins awarded in database');
  }, 3000);
}