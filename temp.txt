socket.on('join', async (message) => {
  console.log('üé≠ Fashion Show - Received join:', message);

  // üîß ENHANCED: Better validation with specific error messages
  if (!message || typeof message !== 'object') {
    console.warn('‚ö†Ô∏è Invalid join message format. Disconnecting.');
    socket.emit('error', { 
      message: 'Invalid join request format',
      type: 'validation_error',
      severity: 'error'
    });
    return socket.disconnect();
  }

  if (!message.playerId || !message.catId) {
    console.warn('‚ö†Ô∏è Missing playerId or catId. Disconnecting.');
    socket.emit('error', { 
      message: 'Invalid join request - missing player or cat data',
      type: 'validation_error',
      severity: 'error'
    });
    return socket.disconnect();
  }

  // üîß ENHANCED: Validate data types
  const playerId = parseInt(message.playerId);
  const catId = parseInt(message.catId);
  
  if (isNaN(playerId) || isNaN(catId) || playerId <= 0 || catId <= 0) {
    console.warn(`‚ö†Ô∏è Invalid playerId or catId format: playerId=${message.playerId}, catId=${message.catId}`);
    socket.emit('error', { 
      message: 'Invalid player or cat ID format',
      type: 'validation_error',
      severity: 'error'
    });
    return socket.disconnect();
  }

  try {
    // Validate cat ownership BEFORE creating participant
    const catValidation = await DB.query(
      'SELECT cat_id FROM player_cats WHERE cat_id = $1 AND player_id = $2',
      [catId, playerId]
    );

    if (catValidation.rows.length === 0) {
      console.warn(`‚ùå Player ${playerId} does not own cat ${catId}. Disconnecting.`);
      socket.emit('error', { 
        message: 'You do not own the selected cat',
        type: 'ownership_error',
        severity: 'error'
      });
      return socket.disconnect();
    }
  } catch (err) {
    console.error('‚ùå Database error during cat validation:', err);
    socket.emit('error', { 
      message: 'Database connection error - please try again',
      type: 'database_error',
      severity: 'error'
    });
    return socket.disconnect();
  }

  // üîß ENHANCED: Better duplicate checking with detailed logging
  const existingParticipant = waitingRoom.participants.find(p => 
    p.playerId === playerId || (p.playerId === playerId && p.catId === catId)
  );

  if (existingParticipant) {
    console.warn(`‚ùå Player ${playerId} already in waiting room. Existing: playerId=${existingParticipant.playerId}, catId=${existingParticipant.catId}`);
    socket.emit('error', { 
      message: 'You are already in the waiting room',
      type: 'duplicate_join',
      severity: 'warning'
    });
    return socket.disconnect();
  }

  try {
    // Create participant with enhanced error handling
    socket.participant = await createParticipant(playerId, catId, socket);
    currentParticipant = socket.participant;
    
    // üîß ENHANCED: Validate participant creation with specific checks
    if (!socket.participant) {
      throw new Error('Participant creation returned null');
    }
    
    if (!socket.participant.username || socket.participant.username.startsWith('Player_')) {
      console.warn(`‚ö†Ô∏è Could not load username for player ${playerId}, using fallback`);
    }
    
    if (!socket.participant.catName || socket.participant.catName.startsWith('Cat_')) {
      console.warn(`‚ö†Ô∏è Could not load cat name for cat ${catId}, using fallback`);
    }
    
    if (!socket.participant.catSpriteUrl) {
      console.warn(`‚ö†Ô∏è Could not load cat sprite for cat ${catId}`);
    }

    console.log(`‚úÖ Valid participant created for ${socket.participant.playerId}: ${socket.participant.catName}`);

  } catch (err) {
    console.error(`‚ùå Failed to create participant for player ${playerId}, cat ${catId}:`, err);
    socket.emit('error', { 
      message: 'Failed to load your cat data - please try again',
      type: 'data_loading_error',
      severity: 'error'
    });
    return socket.disconnect();
  }

  // Continue with existing join logic...
  if (waitingRoom.participants.length < PARTICIPANTS_IN_ROOM && !waitingRoom.isVoting) {
    waitingRoom.participants.push(socket.participant);
    console.log(`üë• Waiting room: ${waitingRoom.participants.length}/${PARTICIPANTS_IN_ROOM}`);
    
    broadcastWaitingRoomUpdate();

    // Launch game room when full
    if (waitingRoom.participants.length === PARTICIPANTS_IN_ROOM) {
      console.log('üöÄ Launching game room');
      
      // Final validation before game start
      const uniqueParticipants = waitingRoom.participants.filter((p, index, arr) => 
        arr.findIndex(other => other.playerId === p.playerId && other.catId === p.catId) === index
      );

      if (uniqueParticipants.length !== PARTICIPANTS_IN_ROOM) {
        console.error(`‚ùå Duplicate participants detected! Expected ${PARTICIPANTS_IN_ROOM}, got ${uniqueParticipants.length} unique`);
        // Reset waiting room and disconnect all with error message
        waitingRoom.participants.forEach(p => {
          if (p.socket?.connected) {
            p.socket.emit('error', { 
              message: 'Room setup error - please try joining again',
              type: 'room_error',
              severity: 'error'
            });
            p.socket.disconnect();
          }
        });
        waitingRoom = { participants: [], isVoting: false };
        return;
      }

      const gameRoom = new GameRoom([...uniqueParticipants]);

      // üîß FIX: Properly assign game room to all participant sockets
      uniqueParticipants.forEach(p => {
        if (!p.isDummy && p.socket) {
          p.socket.currentGameRoom = gameRoom;
          console.log(`üîó Assigned game room to ${p.username}'s socket`);
        }
      });

      // Reset waiting room
      waitingRoom = { participants: [], isVoting: false };
    }
  } else {
    console.warn('‚ùå Waiting room full or voting. Disconnecting.');
    socket.emit('error', { 
      message: 'Fashion show room is full - please try again later',
      type: 'room_full',
      severity: 'info'
    });
    socket.disconnect();
  }
});