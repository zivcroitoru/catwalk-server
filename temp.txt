  async finalizeVoting() {
    if (this.isFinalized) return;
    this.isFinalized = true;

    console.log("üèÅ FINALIZING VOTING - No more changes allowed");

    // Record finalization time for analytics
    const votingDuration = ((Date.now() - this.votingStartTime) / 1000).toFixed(1);
    console.log(`‚è±Ô∏è Voting lasted ${votingDuration} seconds`);

    // Clear timer if still running
    if (this.votingTimer) {
      clearTimeout(this.votingTimer);
      this.votingTimer = null;
      console.log("‚èπÔ∏è Voting timer cleared");
    }

    // üîß ONLY calculate results, NO database updates yet
    this.calculateResults();

    // Show announcement before results
    console.log('üì∫ Sending "calculating votes" announcement to participants');
    this.participants.forEach((participant) => {
      if (participant.socket?.connected) {
        participant.socket.emit("calculating_announcement", {
          type: "calculating_announcement",
          message: "CALCULATING VOTES, PLEASE WAIT . . .",
        });
      }
    });

    // üîß CRITICAL CHANGE: Longer delay to allow disconnects to be processed
    // This gives time for players to disconnect during "calculating votes..." phase
    // and be marked as dummy BEFORE database updates happen
    setTimeout(async () => {
      console.log("üí∞ CALCULATION PHASE COMPLETE - NOW APPLYING DATABASE UPDATES");
      console.log("üîí From this point forward, disconnects will NOT affect coin awards");

      try {
        // üîß ENHANCED: Check for dummy participants right before DB updates
        console.log("üîç PRE-DATABASE UPDATE DUMMY CHECK:");
        this.participants.forEach((p, idx) => {
          console.log(`  ${idx + 1}. ${p.username} (${p.playerId}) - isDummy: ${p.isDummy || false}`);
          if (p.isDummy) {
            console.log(`     ‚ö†Ô∏è ${p.username} marked as dummy - will not receive coins`);
          }
        });

        // Update database with rewards
        const dbUpdateSummary = await this.updateDatabaseWithRewards();

        console.log("üì§ Sending final results to all participants (coins processing complete)");

        // Send results with comprehensive error handling
        let resultsMessagesSent = 0;
        let resultsMessagesFailed = 0;

        this.participants.forEach((participant) => {
          if (participant.socket?.connected) {
            try {
              // Validate toast data before sending
              const toastData = participant.toastData || {
                success: false,
                error: "No toast data generated",
                coinsEarned: 0,
                votesReceived: participant.votesReceived || 0,
              };

              // Ensure required fields are present
              if (!toastData.hasOwnProperty("success")) {
                console.warn(`‚ö†Ô∏è Missing 'success' field in toast data for ${participant.username}`);
                toastData.success = false;
                toastData.error = "incomplete_toast_data";
              }

              if (!toastData.hasOwnProperty("coinsEarned")) {
                console.warn(`‚ö†Ô∏è Missing 'coinsEarned' field in toast data for ${participant.username}`);
                toastData.coinsEarned = 0;
              }

              if (!toastData.hasOwnProperty("votesReceived")) {
                console.warn(`‚ö†Ô∏è Missing 'votesReceived' field in toast data for ${participant.username}`);
                toastData.votesReceived = participant.votesReceived || 0;
              }

              const resultsMessage = {
                type: "results",
                participants: this.getParticipantsForClient(),
                toastData: toastData,
              };

              participant.socket.emit("results", resultsMessage);
              resultsMessagesSent++;

              console.log(`  ‚úÖ Results sent to ${participant.username} with toast data:`, toastData);
            } catch (err) {
              console.error(`‚ùå Failed to send results to ${participant.username}:`, err);
              resultsMessagesFailed++;
            }
          } else {
            console.log(`  ‚ö†Ô∏è Could not send results to ${participant.username} - socket disconnected`);
            resultsMessagesFailed++;
          }
        });

        console.log(`üìä Results delivery summary: ${resultsMessagesSent} sent, ${resultsMessagesFailed} failed`);
        console.log("üéâ GAME ROOM COMPLETE - Results displayed, coins awarded in database");
      } catch (error) {
        console.error("‚ùå CRITICAL ERROR during database updates:", error);

        // Send error results to participants if DB updates fail completely
        this.participants.forEach((participant) => {
          if (participant.socket?.connected) {
            const errorToastData = {
              success: false,
              error: "database_update_failed",
              coinsEarned: 0,
              votesReceived: participant.votesReceived || 0,
              details: "Server error during coin processing",
            };

            const resultsMessage = {
              type: "results",
              participants: this.getParticipantsForClient(),
              toastData: errorToastData,
            };

            participant.socket.emit("results", resultsMessage);
            console.log(`  ‚ö†Ô∏è Error results sent to ${participant.username}`);
          }
        });
      }
    }, 5000); // üîß INCREASED from 3000 to 5000ms (5 seconds)
    // This gives more time for disconnects during "calculating votes..." phase
  }